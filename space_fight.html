<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Falling Blocks Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(270deg, #ff0080, #ff8c00, #40e0d0, #8a2be2);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            overflow: hidden;
            touch-action: none;
            font-family: Arial, sans-serif;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #gameContainer {
            position: relative;
            text-align: center;
        }

        canvas {
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 5px #000;
            font-family: 'Courier New', monospace;
        }

        #controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            background: #ffcc66;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        #touchControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: center;
            gap: 15px;
        }

        #touchControls button {
            font-size: 24px;
            padding: 15px 25px;
            background: rgba(255, 204, 102, 0.7);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="score">Score: 0</div>
        <div id="controls">
            <button id="startBtn">Start</button>
            <button id="pauseBtn">Pause</button>
        </div>
        <div id="touchControls">
            <button ontouchstart="moveBlock(-1,0)">←</button>
            <button ontouchstart="moveBlock(1,0)">→</button>
            <button ontouchstart="moveBlock(0,1)">↓</button>
            <button ontouchstart="rotateBlock()">↻</button>
        </div>
    </div>

    <!-- Sounds -->
    <audio id="bgMusic" loop>
        <source src="https://cdn.pixabay.com/download/audio/2025/07/22/audio_377647.mp3" type="audio/mpeg">
    </audio>
    <audio id="beepSound" src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_beep.mp3" preload="auto"></audio>
    <audio id="clickSound" src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_click.mp3" preload="auto"></audio>

    <script>
        // Game Configuration
        const COLS = 10, ROWS = 20;
        let BLOCK_SIZE, canvas, ctx;
        let board = [];
        let currentBlock = null;
        let score = 0;
        let gameOver = false;
        let gameStarted = false;
        let gamePaused = false;
        let dropInterval = 500;
        let lastDropTime = 0;
        const colors = ['#FF5252', '#FFD740', '#69F0AE', '#40C4FF', '#E040FB'];
        const bgMusic = document.getElementById('bgMusic');
        const beepSound = document.getElementById('beepSound');
        const clickSound = document.getElementById('clickSound');

        // Sound Functions
        function playBeep() { beepSound.currentTime = 0; beepSound.play(); }
        function playClick() { clickSound.currentTime = 0; clickSound.play(); }

        // Initialize Game
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            initBoard();
            draw();
            setupControls();
            setupTouch();
            requestAnimationFrame(update);
        }

        // Resize Canvas
        function resizeCanvas() {
            const maxWidth = window.innerWidth * 0.9;
            const maxHeight = window.innerHeight * 0.7;
            BLOCK_SIZE = Math.min(Math.floor(maxWidth / COLS), Math.floor(maxHeight / ROWS));
            canvas.width = COLS * BLOCK_SIZE;
            canvas.height = ROWS * BLOCK_SIZE;
        }

        // Initialize Board
        function initBoard() {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        // Draw Game
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) drawBlock(c, r, board[r][c]);
                }
            }
            if (currentBlock) {
                for (let r = 0; r < currentBlock.shape.length; r++) {
                    for (let c = 0; c < currentBlock.shape[0].length; c++) {
                        if (currentBlock.shape[r][c]) {
                            drawBlock(currentBlock.x + c, currentBlock.y + r, currentBlock.color);
                        }
                    }
                }
            }
        }

        // Draw Block
        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }

        // Create New Block
        function newBlock() {
            const shapes = [[[1]], [[1, 1]], [[1, 1, 1]], [[1, 1], [1, 1]]];
            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            const color = colors[Math.floor(Math.random() * colors.length)];
            currentBlock = {
                shape: shape,
                color: color,
                x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0
            };
            if (checkCollision()) {
                gameOver = true;
                alert('Game Over! Score: ' + score);
            }
        }

        // Check Collision
        function checkCollision() {
            for (let r = 0; r < currentBlock.shape.length; r++) {
                for (let c = 0; c < currentBlock.shape[0].length; c++) {
                    if (currentBlock.shape[r][c]) {
                        const newX = currentBlock.x + c;
                        const newY = currentBlock.y + r;
                        if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
                        if (newY >= 0 && board[newY][newX]) return true;
                    }
                }
            }
            return false;
        }

        // Move Block
        function moveBlock(dx, dy) {
            if (!gameStarted || gamePaused || gameOver) return;
            currentBlock.x += dx;
            currentBlock.y += dy;
            if (checkCollision()) {
                currentBlock.x -= dx;
                currentBlock.y -= dy;
                if (dy === 1) {
                    placeBlock();
                    playBeep();
                }
            }
        }

        // Place Block
        function placeBlock() {
            for (let r = 0; r < currentBlock.shape.length; r++) {
                for (let c = 0; c < currentBlock.shape[0].length; c++) {
                    if (currentBlock.shape[r][c]) {
                        const x = currentBlock.x + c;
                        const y = currentBlock.y + r;
                        if (y >= 0) board[y][x] = currentBlock.color;
                    }
                }
            }
            clearLines();
            newBlock();
        }

        // Clear Lines
        function clearLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    board.splice(r, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    r++;
                }
            }
            if (linesCleared > 0) {
                score += linesCleared * 10;
                document.getElementById('score').textContent = 'Score: ' + score;
            }
        }

        // Rotate Block
        function rotateBlock() {
            if (!currentBlock) return;
            const original = currentBlock.shape;
            const rows = original.length, cols = original[0].length;
            const newShape = Array.from({ length: cols }, () => Array(rows).fill(0));
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    newShape[c][rows - 1 - r] = original[r][c];
                }
            }
            currentBlock.shape = newShape;
            if (checkCollision()) currentBlock.shape = original;
        }

        // Toggle Pause
        function togglePause() {
            if (!gameStarted) return;
            gamePaused = !gamePaused;
            document.getElementById('pauseBtn').textContent = gamePaused ? 'Resume' : 'Pause';
            if (gamePaused) bgMusic.pause(); else bgMusic.play();
        }

        // Setup Controls
        function setupControls() {
            // Keyboard Controls
            document.addEventListener('keydown', e => {
                if (!gameStarted || gameOver) return;
                switch (e.key) {
                    case 'ArrowLeft': moveBlock(-1, 0); break;
                    case 'ArrowRight': moveBlock(1, 0); break;
                    case 'ArrowDown': moveBlock(0, 1); break;
                    case 'ArrowUp': rotateBlock(); break;
                    case 'p': togglePause(); break;
                }
            });

            // Button Controls
            document.getElementById('startBtn').addEventListener('click', () => {
                playClick();
                if (!gameStarted) {
                    gameStarted = true;
                    gameOver = false;
                    initBoard();
                    score = 0;
                    document.getElementById('score').textContent = 'Score: 0';
                    newBlock();
                    bgMusic.play();
                }
            });

            document.getElementById('pauseBtn').addEventListener('click', () => {
                playClick();
                togglePause();
            });
        }

        // Setup Touch Controls
        function setupTouch() {
            let touchStartX = 0, touchStartY = 0;

            // Show Touch Buttons on Mobile
            if ('ontouchstart' in window) {
                document.getElementById('touchControls').style.display = 'flex';
            }

            // Swipe Controls
            canvas.addEventListener('touchstart', e => {
                if (!gameStarted) return;
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            });

            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if (!gameStarted) return;
                const touch = e.touches[0];
                const dx = touch.clientX - touchStartX;
                const dy = touch.clientY - touchStartY;
                if (Math.abs(dx) > BLOCK_SIZE / 3) {
                    moveBlock(dx > 0 ? 1 : -1, 0);
                    touchStartX = touch.clientX;
                }
                if (Math.abs(dy) > BLOCK_SIZE / 3) {
                    moveBlock(0, dy > 0 ? 1 : -1);
                    touchStartY = touch.clientY;
                }
            }, { passive: false });

            // Tap to Rotate
            canvas.addEventListener('touchend', e => {
                if (!gameStarted) return;
                rotateBlock();
            });
        }

        // Game Loop
        function update(timestamp) {
            if (gameStarted && !gamePaused && !gameOver) {
                if (timestamp - lastDropTime > dropInterval) {
                    moveBlock(0, 1);
                    lastDropTime = timestamp;
                }
            }
            draw();
            requestAnimationFrame(update);
        }

        // Start Game
        window.onload = initGame;
    </script>
</body>
</html>
